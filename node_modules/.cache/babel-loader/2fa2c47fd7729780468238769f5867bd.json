{"ast":null,"code":"/**\n    * @license\n    * Copyright 2019 Google LLC. All Rights Reserved.\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    * http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    * =============================================================================\n    */\nimport * as tf from \"@tensorflow/tfjs-core\";\nimport { util, tidy, div, sub, buffer, Tensor, browser, pad3d, scalar, concat, tensor2d, tensor } from \"@tensorflow/tfjs-core\";\nimport { loadGraphModel } from \"@tensorflow/tfjs-converter\";\nvar VALID_OUTPUT_STRIDES = [8, 16, 32];\n\nfunction assertValidOutputStride(e) {\n  util.assert(\"number\" == typeof e, function () {\n    return \"outputStride is not a number\";\n  }), util.assert(VALID_OUTPUT_STRIDES.indexOf(e) >= 0, function () {\n    return \"outputStride of \" + e + \" is invalid. It must be either 8, 16, or 32\";\n  });\n}\n\nfunction assertValidResolution(e, t) {\n  util.assert(\"number\" == typeof e, function () {\n    return \"resolution is not a number\";\n  }), util.assert((e - 1) % t == 0, function () {\n    return \"resolution of \" + e + \" is invalid for output stride \" + t + \".\";\n  });\n}\n\nfunction toFloatIfInt(e) {\n  return tidy(function () {\n    return \"int32\" === e.dtype && (e = e.toFloat()), e = div(e, 127.5), sub(e, 1);\n  });\n}\n\nvar MobileNet = function () {\n  function e(e, t) {\n    this.model = e;\n    var r = this.model.inputs[0].shape;\n    util.assert(-1 === r[1] && -1 === r[2], function () {\n      return \"Input shape [\" + r[1] + \", \" + r[2] + \"] must both be -1\";\n    }), this.outputStride = t;\n  }\n\n  return e.prototype.predict = function (e) {\n    var t = this;\n    return tidy(function () {\n      var r = toFloatIfInt(e).expandDims(0),\n          n = t.model.predict(r),\n          o = n[0],\n          i = n[1],\n          s = n[2],\n          a = n[3];\n      return {\n        heatmapScores: i.squeeze().sigmoid(),\n        offsets: o.squeeze(),\n        displacementFwd: s.squeeze(),\n        displacementBwd: a.squeeze()\n      };\n    });\n  }, e.prototype.dispose = function () {\n    this.model.dispose();\n  }, e;\n}();\n\nfunction half(e) {\n  return Math.floor(e / 2);\n}\n\nvar MaxHeap = function () {\n  function e(e, t) {\n    this.priorityQueue = new Array(e), this.numberOfElements = -1, this.getElementValue = t;\n  }\n\n  return e.prototype.enqueue = function (e) {\n    this.priorityQueue[++this.numberOfElements] = e, this.swim(this.numberOfElements);\n  }, e.prototype.dequeue = function () {\n    var e = this.priorityQueue[0];\n    return this.exchange(0, this.numberOfElements--), this.sink(0), this.priorityQueue[this.numberOfElements + 1] = null, e;\n  }, e.prototype.empty = function () {\n    return -1 === this.numberOfElements;\n  }, e.prototype.size = function () {\n    return this.numberOfElements + 1;\n  }, e.prototype.all = function () {\n    return this.priorityQueue.slice(0, this.numberOfElements + 1);\n  }, e.prototype.max = function () {\n    return this.priorityQueue[0];\n  }, e.prototype.swim = function (e) {\n    for (; e > 0 && this.less(half(e), e);) this.exchange(e, half(e)), e = half(e);\n  }, e.prototype.sink = function (e) {\n    for (; 2 * e <= this.numberOfElements;) {\n      var t = 2 * e;\n      if (t < this.numberOfElements && this.less(t, t + 1) && t++, !this.less(e, t)) break;\n      this.exchange(e, t), e = t;\n    }\n  }, e.prototype.getValueAt = function (e) {\n    return this.getElementValue(this.priorityQueue[e]);\n  }, e.prototype.less = function (e, t) {\n    return this.getValueAt(e) < this.getValueAt(t);\n  }, e.prototype.exchange = function (e, t) {\n    var r = this.priorityQueue[e];\n    this.priorityQueue[e] = this.priorityQueue[t], this.priorityQueue[t] = r;\n  }, e;\n}();\n\nfunction scoreIsMaximumInLocalWindow(e, t, r, n, o, i) {\n  for (var s = i.shape, a = s[0], u = s[1], l = !0, f = Math.max(r - o, 0), c = Math.min(r + o + 1, a), d = f; d < c; ++d) {\n    for (var p = Math.max(n - o, 0), h = Math.min(n + o + 1, u), m = p; m < h; ++m) if (i.get(d, m, e) > t) {\n      l = !1;\n      break;\n    }\n\n    if (!l) break;\n  }\n\n  return l;\n}\n\nfunction buildPartWithScoreQueue(e, t, r) {\n  for (var n = r.shape, o = n[0], i = n[1], s = n[2], a = new MaxHeap(o * i * s, function (e) {\n    return e.score;\n  }), u = 0; u < o; ++u) for (var l = 0; l < i; ++l) for (var f = 0; f < s; ++f) {\n    var c = r.get(u, l, f);\n    c < e || scoreIsMaximumInLocalWindow(f, c, u, l, t, r) && a.enqueue({\n      score: c,\n      part: {\n        heatmapY: u,\n        heatmapX: l,\n        id: f\n      }\n    });\n  }\n\n  return a;\n}\n\nvar partNames = [\"nose\", \"leftEye\", \"rightEye\", \"leftEar\", \"rightEar\", \"leftShoulder\", \"rightShoulder\", \"leftElbow\", \"rightElbow\", \"leftWrist\", \"rightWrist\", \"leftHip\", \"rightHip\", \"leftKnee\", \"rightKnee\", \"leftAnkle\", \"rightAnkle\"],\n    NUM_KEYPOINTS = partNames.length,\n    partIds = partNames.reduce(function (e, t, r) {\n  return e[t] = r, e;\n}, {}),\n    connectedPartNames = [[\"leftHip\", \"leftShoulder\"], [\"leftElbow\", \"leftShoulder\"], [\"leftElbow\", \"leftWrist\"], [\"leftHip\", \"leftKnee\"], [\"leftKnee\", \"leftAnkle\"], [\"rightHip\", \"rightShoulder\"], [\"rightElbow\", \"rightShoulder\"], [\"rightElbow\", \"rightWrist\"], [\"rightHip\", \"rightKnee\"], [\"rightKnee\", \"rightAnkle\"], [\"leftShoulder\", \"rightShoulder\"], [\"leftHip\", \"rightHip\"]],\n    poseChain = [[\"nose\", \"leftEye\"], [\"leftEye\", \"leftEar\"], [\"nose\", \"rightEye\"], [\"rightEye\", \"rightEar\"], [\"nose\", \"leftShoulder\"], [\"leftShoulder\", \"leftElbow\"], [\"leftElbow\", \"leftWrist\"], [\"leftShoulder\", \"leftHip\"], [\"leftHip\", \"leftKnee\"], [\"leftKnee\", \"leftAnkle\"], [\"nose\", \"rightShoulder\"], [\"rightShoulder\", \"rightElbow\"], [\"rightElbow\", \"rightWrist\"], [\"rightShoulder\", \"rightHip\"], [\"rightHip\", \"rightKnee\"], [\"rightKnee\", \"rightAnkle\"]],\n    connectedPartIndices = connectedPartNames.map(function (e) {\n  var t = e[0],\n      r = e[1];\n  return [partIds[t], partIds[r]];\n}),\n    partChannels = [\"left_face\", \"right_face\", \"right_upper_leg_front\", \"right_lower_leg_back\", \"right_upper_leg_back\", \"left_lower_leg_front\", \"left_upper_leg_front\", \"left_upper_leg_back\", \"left_lower_leg_back\", \"right_feet\", \"right_lower_leg_front\", \"left_feet\", \"torso_front\", \"torso_back\", \"right_upper_arm_front\", \"right_upper_arm_back\", \"right_lower_arm_back\", \"left_lower_arm_front\", \"left_upper_arm_front\", \"left_upper_arm_back\", \"left_lower_arm_back\", \"right_hand\", \"right_lower_arm_front\", \"left_hand\"];\n\nfunction getOffsetPoint(e, t, r, n) {\n  return {\n    y: n.get(e, t, r),\n    x: n.get(e, t, r + NUM_KEYPOINTS)\n  };\n}\n\nfunction getImageCoords(e, t, r) {\n  var n = getOffsetPoint(e.heatmapY, e.heatmapX, e.id, r),\n      o = n.y,\n      i = n.x;\n  return {\n    x: e.heatmapX * t + i,\n    y: e.heatmapY * t + o\n  };\n}\n\nfunction clamp(e, t, r) {\n  return e < t ? t : e > r ? r : e;\n}\n\nfunction squaredDistance(e, t, r, n) {\n  var o = r - e,\n      i = n - t;\n  return o * o + i * i;\n}\n\nfunction addVectors(e, t) {\n  return {\n    x: e.x + t.x,\n    y: e.y + t.y\n  };\n}\n\nvar parentChildrenTuples = poseChain.map(function (e) {\n  var t = e[0],\n      r = e[1];\n  return [partIds[t], partIds[r]];\n}),\n    parentToChildEdges = parentChildrenTuples.map(function (e) {\n  return e[1];\n}),\n    childToParentEdges = parentChildrenTuples.map(function (e) {\n  return e[0];\n});\n\nfunction getDisplacement(e, t, r) {\n  var n = r.shape[2] / 2;\n  return {\n    y: r.get(t.y, t.x, e),\n    x: r.get(t.y, t.x, n + e)\n  };\n}\n\nfunction getStridedIndexNearPoint(e, t, r, n) {\n  return {\n    y: clamp(Math.round(e.y / t), 0, r - 1),\n    x: clamp(Math.round(e.x / t), 0, n - 1)\n  };\n}\n\nfunction traverseToTargetKeypoint(e, t, r, n, o, i, s, a) {\n  void 0 === a && (a = 2);\n\n  for (var u = n.shape, l = u[0], f = u[1], c = getDisplacement(e, getStridedIndexNearPoint(t.position, i, l, f), s), d = addVectors(t.position, c), p = 0; p < a; p++) {\n    var h = getStridedIndexNearPoint(d, i, l, f),\n        m = getOffsetPoint(h.y, h.x, r, o);\n    d = addVectors({\n      x: h.x * i,\n      y: h.y * i\n    }, {\n      x: m.x,\n      y: m.y\n    });\n  }\n\n  var g = getStridedIndexNearPoint(d, i, l, f),\n      _ = n.get(g.y, g.x, r);\n\n  return {\n    position: d,\n    part: partNames[r],\n    score: _\n  };\n}\n\nfunction decodePose(e, t, r, n, o, i) {\n  var s = t.shape[2],\n      a = parentToChildEdges.length,\n      u = new Array(s),\n      l = e.part,\n      f = e.score,\n      c = getImageCoords(l, n, r);\n  u[l.id] = {\n    score: f,\n    part: partNames[l.id],\n    position: c\n  };\n\n  for (var d = a - 1; d >= 0; --d) {\n    var p = parentToChildEdges[d],\n        h = childToParentEdges[d];\n    u[p] && !u[h] && (u[h] = traverseToTargetKeypoint(d, u[p], h, t, r, n, i));\n  }\n\n  for (d = 0; d < a; ++d) {\n    p = childToParentEdges[d], h = parentToChildEdges[d];\n    u[p] && !u[h] && (u[h] = traverseToTargetKeypoint(d, u[p], h, t, r, n, o));\n  }\n\n  return u;\n}\n\nfunction withinNmsRadiusOfCorrespondingPoint(e, t, r, n) {\n  var o = r.x,\n      i = r.y;\n  return e.some(function (e) {\n    var r = e.keypoints[n].position;\n    return squaredDistance(i, o, r.y, r.x) <= t;\n  });\n}\n\nfunction getInstanceScore(e, t, r) {\n  return r.reduce(function (r, n, o) {\n    var i = n.position,\n        s = n.score;\n    return withinNmsRadiusOfCorrespondingPoint(e, t, i, o) || (r += s), r;\n  }, 0) / r.length;\n}\n\nvar kLocalMaximumRadius = 1;\n\nfunction decodeMultiplePoses(e, t, r, n, o, i, s, a) {\n  void 0 === s && (s = .5), void 0 === a && (a = 20);\n\n  for (var u = [], l = buildPartWithScoreQueue(s, kLocalMaximumRadius, e), f = a * a; u.length < i && !l.empty();) {\n    var c = l.dequeue();\n\n    if (!withinNmsRadiusOfCorrespondingPoint(u, f, getImageCoords(c.part, o, t), c.part.id)) {\n      var d = decodePose(c, e, t, o, r, n),\n          p = getInstanceScore(u, f, d);\n      u.push({\n        keypoints: d,\n        score: p\n      });\n    }\n  }\n\n  return u;\n}\n\nvar __assign = function () {\n  return (__assign = Object.assign || function (e) {\n    for (var t, r = 1, n = arguments.length; r < n; r++) for (var o in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);\n\n    return e;\n  }).apply(this, arguments);\n};\n\nfunction __awaiter(e, t, r, n) {\n  return new (r || (r = Promise))(function (o, i) {\n    function s(e) {\n      try {\n        u(n.next(e));\n      } catch (e) {\n        i(e);\n      }\n    }\n\n    function a(e) {\n      try {\n        u(n.throw(e));\n      } catch (e) {\n        i(e);\n      }\n    }\n\n    function u(e) {\n      e.done ? o(e.value) : new r(function (t) {\n        t(e.value);\n      }).then(s, a);\n    }\n\n    u((n = n.apply(e, t || [])).next());\n  });\n}\n\nfunction __generator(e, t) {\n  var r,\n      n,\n      o,\n      i,\n      s = {\n    label: 0,\n    sent: function () {\n      if (1 & o[0]) throw o[1];\n      return o[1];\n    },\n    trys: [],\n    ops: []\n  };\n  return i = {\n    next: a(0),\n    throw: a(1),\n    return: a(2)\n  }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n    return this;\n  }), i;\n\n  function a(i) {\n    return function (a) {\n      return function (i) {\n        if (r) throw new TypeError(\"Generator is already executing.\");\n\n        for (; s;) try {\n          if (r = 1, n && (o = 2 & i[0] ? n.return : i[0] ? n.throw || ((o = n.return) && o.call(n), 0) : n.next) && !(o = o.call(n, i[1])).done) return o;\n\n          switch (n = 0, o && (i = [2 & i[0], o.value]), i[0]) {\n            case 0:\n            case 1:\n              o = i;\n              break;\n\n            case 4:\n              return s.label++, {\n                value: i[1],\n                done: !1\n              };\n\n            case 5:\n              s.label++, n = i[1], i = [0];\n              continue;\n\n            case 7:\n              i = s.ops.pop(), s.trys.pop();\n              continue;\n\n            default:\n              if (!(o = (o = s.trys).length > 0 && o[o.length - 1]) && (6 === i[0] || 2 === i[0])) {\n                s = 0;\n                continue;\n              }\n\n              if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {\n                s.label = i[1];\n                break;\n              }\n\n              if (6 === i[0] && s.label < o[1]) {\n                s.label = o[1], o = i;\n                break;\n              }\n\n              if (o && s.label < o[2]) {\n                s.label = o[2], s.ops.push(i);\n                break;\n              }\n\n              o[2] && s.ops.pop(), s.trys.pop();\n              continue;\n          }\n\n          i = t.call(e, s);\n        } catch (e) {\n          i = [6, e], n = 0;\n        } finally {\n          r = o = 0;\n        }\n\n        if (5 & i[0]) throw i[1];\n        return {\n          value: i[0] ? i[1] : void 0,\n          done: !0\n        };\n      }([i, a]);\n    };\n  }\n}\n\nfunction eitherPointDoesntMeetConfidence(e, t, r) {\n  return e < r || t < r;\n}\n\nfunction getAdjacentKeyPoints(e, t) {\n  return connectedPartIndices.reduce(function (r, n) {\n    var o = n[0],\n        i = n[1];\n    return eitherPointDoesntMeetConfidence(e[o].score, e[i].score, t) ? r : (r.push([e[o], e[i]]), r);\n  }, []);\n}\n\nvar NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,\n    POSITIVE_INFINITY = Number.POSITIVE_INFINITY;\n\nfunction getBoundingBox(e) {\n  return e.reduce(function (e, t) {\n    var r = e.maxX,\n        n = e.maxY,\n        o = e.minX,\n        i = e.minY,\n        s = t.position,\n        a = s.x,\n        u = s.y;\n    return {\n      maxX: Math.max(r, a),\n      maxY: Math.max(n, u),\n      minX: Math.min(o, a),\n      minY: Math.min(i, u)\n    };\n  }, {\n    maxX: NEGATIVE_INFINITY,\n    maxY: NEGATIVE_INFINITY,\n    minX: POSITIVE_INFINITY,\n    minY: POSITIVE_INFINITY\n  });\n}\n\nfunction getBoundingBoxPoints(e) {\n  var t = getBoundingBox(e),\n      r = t.minX,\n      n = t.minY,\n      o = t.maxX,\n      i = t.maxY;\n  return [{\n    x: r,\n    y: n\n  }, {\n    x: o,\n    y: n\n  }, {\n    x: o,\n    y: i\n  }, {\n    x: r,\n    y: i\n  }];\n}\n\nfunction toTensorBuffer(e, t) {\n  return void 0 === t && (t = \"float32\"), __awaiter(this, void 0, void 0, function () {\n    var r;\n    return __generator(this, function (n) {\n      switch (n.label) {\n        case 0:\n          return [4, e.data()];\n\n        case 1:\n          return r = n.sent(), [2, buffer(e.shape, t, r)];\n      }\n    });\n  });\n}\n\nfunction toTensorBuffers3D(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (t) {\n      return [2, Promise.all(e.map(function (e) {\n        return toTensorBuffer(e, \"float32\");\n      }))];\n    });\n  });\n}\n\nfunction scalePose(e, t, r, n, o) {\n  return void 0 === n && (n = 0), void 0 === o && (o = 0), {\n    score: e.score,\n    keypoints: e.keypoints.map(function (e) {\n      var i = e.score,\n          s = e.part,\n          a = e.position;\n      return {\n        score: i,\n        part: s,\n        position: {\n          x: a.x * r + o,\n          y: a.y * t + n\n        }\n      };\n    })\n  };\n}\n\nfunction scalePoses(e, t, r, n, o) {\n  return void 0 === n && (n = 0), void 0 === o && (o = 0), 1 === r && 1 === t && 0 === n && 0 === o ? e : e.map(function (e) {\n    return scalePose(e, t, r, n, o);\n  });\n}\n\nfunction flipPoseHorizontal(e, t) {\n  return {\n    score: e.score,\n    keypoints: e.keypoints.map(function (e) {\n      var r = e.score,\n          n = e.part,\n          o = e.position;\n      return {\n        score: r,\n        part: n,\n        position: {\n          x: t - 1 - o.x,\n          y: o.y\n        }\n      };\n    })\n  };\n}\n\nfunction flipPosesHorizontal(e, t) {\n  return t <= 0 ? e : e.map(function (e) {\n    return flipPoseHorizontal(e, t);\n  });\n}\n\nfunction getInputTensorDimensions(e) {\n  return e instanceof Tensor ? [e.shape[0], e.shape[1]] : [e.height, e.width];\n}\n\nfunction toInputTensor(e) {\n  return e instanceof Tensor ? e : browser.fromPixels(e);\n}\n\nfunction padAndResizeTo(e, t) {\n  var r = t[0],\n      n = t[1],\n      o = getInputTensorDimensions(e),\n      i = o[0],\n      s = o[1],\n      a = n / r,\n      u = [0, 0, 0, 0],\n      l = u[0],\n      f = u[1],\n      c = u[2],\n      d = u[3];\n  return s / i < a ? (l = 0, f = 0, c = Math.round(.5 * (a * i - s)), d = Math.round(.5 * (a * i - s))) : (l = Math.round(.5 * (1 / a * s - i)), f = Math.round(.5 * (1 / a * s - i)), c = 0, d = 0), {\n    resized: tidy(function () {\n      var t = toInputTensor(e);\n      return (t = pad3d(t, [[l, f], [c, d], [0, 0]])).resizeBilinear([r, n]);\n    }),\n    padding: {\n      top: l,\n      left: c,\n      right: d,\n      bottom: f\n    }\n  };\n}\n\nfunction scaleAndFlipPoses(e, t, r, n, o) {\n  var i = t[0],\n      s = t[1],\n      a = r[0],\n      u = r[1],\n      l = scalePoses(e, (i + n.top + n.bottom) / a, (s + n.left + n.right) / u, -n.top, -n.left);\n  return o ? flipPosesHorizontal(l, s) : l;\n}\n\nfunction mod(e, t) {\n  return tidy(function () {\n    var r = e.div(scalar(t, \"int32\"));\n    return e.sub(r.mul(scalar(t, \"int32\")));\n  });\n}\n\nfunction argmax2d(e) {\n  var t = e.shape,\n      r = t[0],\n      n = t[1],\n      o = t[2];\n  return tidy(function () {\n    var t = e.reshape([r * n, o]).argMax(0),\n        i = t.div(scalar(n, \"int32\")).expandDims(1),\n        s = mod(t, n).expandDims(1);\n    return concat([i, s], 1);\n  });\n}\n\nfunction getPointsConfidence(e, t) {\n  for (var r = t.shape[0], n = new Float32Array(r), o = 0; o < r; o++) {\n    var i = t.get(o, 0),\n        s = t.get(o, 1);\n    n[o] = e.get(i, s, o);\n  }\n\n  return n;\n}\n\nfunction getOffsetPoint$1(e, t, r, n) {\n  return {\n    y: n.get(e, t, r),\n    x: n.get(e, t, r + NUM_KEYPOINTS)\n  };\n}\n\nfunction getOffsetVectors(e, t) {\n  for (var r = [], n = 0; n < NUM_KEYPOINTS; n++) {\n    var o = getOffsetPoint$1(e.get(n, 0).valueOf(), e.get(n, 1).valueOf(), n, t),\n        i = o.x,\n        s = o.y;\n    r.push(s), r.push(i);\n  }\n\n  return tensor2d(r, [NUM_KEYPOINTS, 2]);\n}\n\nfunction getOffsetPoints(e, t, r) {\n  return tidy(function () {\n    var n = getOffsetVectors(e, r);\n    return e.toTensor().mul(scalar(t, \"int32\")).toFloat().add(n);\n  });\n}\n\nfunction decodeSinglePose(e, t, r) {\n  return __awaiter(this, void 0, void 0, function () {\n    var n, o, i, s, a, u, l, f, c, d;\n    return __generator(this, function (p) {\n      switch (p.label) {\n        case 0:\n          return n = 0, o = argmax2d(e), [4, Promise.all([toTensorBuffer(e), toTensorBuffer(t), toTensorBuffer(o, \"int32\")])];\n\n        case 1:\n          return i = p.sent(), s = i[0], a = i[1], u = i[2], [4, toTensorBuffer(l = getOffsetPoints(u, r, a))];\n\n        case 2:\n          return f = p.sent(), c = Array.from(getPointsConfidence(s, u)), d = c.map(function (e, t) {\n            return n += e, {\n              position: {\n                y: f.get(t, 0),\n                x: f.get(t, 1)\n              },\n              part: partNames[t],\n              score: e\n            };\n          }), o.dispose(), l.dispose(), [2, {\n            keypoints: d,\n            score: n / d.length\n          }];\n      }\n    });\n  });\n}\n\nvar MOBILENET_BASE_URL = \"https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/\",\n    RESNET50_BASE_URL = \"https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/\";\n\nfunction resNet50Checkpoint(e, t) {\n  var r = \"model-stride\" + e + \".json\";\n  return 4 == t ? RESNET50_BASE_URL + \"float/\" + r : RESNET50_BASE_URL + \"quant\" + t + \"/\" + r;\n}\n\nfunction mobileNetCheckpoint(e, t, r) {\n  var n = {\n    1: \"100\",\n    .75: \"075\",\n    .5: \"050\"\n  },\n      o = \"model-stride\" + e + \".json\";\n  return 4 == r ? MOBILENET_BASE_URL + \"float/\" + n[t] + \"/\" + o : MOBILENET_BASE_URL + \"quant\" + r + \"/\" + n[t] + \"/\" + o;\n}\n\nfunction toFloatIfInt$1(e) {\n  return tidy(function () {\n    \"int32\" === e.dtype && (e = e.toFloat());\n    var t = tensor([-123.15, -115.9, -103.06]);\n    return e.add(t);\n  });\n}\n\nvar ResNet = function () {\n  function e(e, t) {\n    this.model = e;\n    var r = this.model.inputs[0].shape;\n    util.assert(-1 === r[1] && -1 === r[2], function () {\n      return \"Input shape [\" + r[1] + \", \" + r[2] + \"] must both be equal to or -1\";\n    }), this.outputStride = t;\n  }\n\n  return e.prototype.predict = function (e) {\n    var t = this;\n    return tidy(function () {\n      var r = toFloatIfInt$1(e).expandDims(0),\n          n = t.model.predict(r),\n          o = n[0],\n          i = n[1],\n          s = n[2];\n      return {\n        heatmapScores: n[3].squeeze().sigmoid(),\n        offsets: s.squeeze(),\n        displacementFwd: o.squeeze(),\n        displacementBwd: i.squeeze()\n      };\n    });\n  }, e.prototype.dispose = function () {\n    this.model.dispose();\n  }, e;\n}(),\n    MOBILENET_V1_CONFIG = {\n  architecture: \"MobileNetV1\",\n  outputStride: 16,\n  multiplier: .75,\n  inputResolution: 257\n},\n    VALID_ARCHITECTURE = [\"MobileNetV1\", \"ResNet50\"],\n    VALID_STRIDE = {\n  MobileNetV1: [8, 16, 32],\n  ResNet50: [32, 16]\n},\n    VALID_INPUT_RESOLUTION = [161, 193, 257, 289, 321, 353, 385, 417, 449, 481, 513, 801],\n    VALID_MULTIPLIER = {\n  MobileNetV1: [.5, .75, 1],\n  ResNet50: [1]\n},\n    VALID_QUANT_BYTES = [1, 2, 4];\n\nfunction validateModelConfig(e) {\n  if (null == (e = e || MOBILENET_V1_CONFIG).architecture && (e.architecture = \"MobileNetV1\"), VALID_ARCHITECTURE.indexOf(e.architecture) < 0) throw new Error(\"Invalid architecture \" + e.architecture + \". Should be one of \" + VALID_ARCHITECTURE);\n  if (null == e.inputResolution && (e.inputResolution = 257), VALID_INPUT_RESOLUTION.indexOf(e.inputResolution) < 0) throw new Error(\"Invalid inputResolution \" + e.inputResolution + \". Should be one of \" + VALID_INPUT_RESOLUTION);\n  if (null == e.outputStride && (e.outputStride = 16), VALID_STRIDE[e.architecture].indexOf(e.outputStride) < 0) throw new Error(\"Invalid outputStride \" + e.outputStride + \". Should be one of \" + VALID_STRIDE[e.architecture] + \" for architecutre \" + e.architecture + \".\");\n  if (null == e.multiplier && (e.multiplier = 1), VALID_MULTIPLIER[e.architecture].indexOf(e.multiplier) < 0) throw new Error(\"Invalid multiplier \" + e.multiplier + \". Should be one of \" + VALID_MULTIPLIER[e.architecture] + \" for architecutre \" + e.architecture + \".\");\n  if (null == e.quantBytes && (e.quantBytes = 4), VALID_QUANT_BYTES.indexOf(e.quantBytes) < 0) throw new Error(\"Invalid quantBytes \" + e.quantBytes + \". Should be one of \" + VALID_QUANT_BYTES + \" for architecutre \" + e.architecture + \".\");\n  return e;\n}\n\nvar SINGLE_PERSON_INFERENCE_CONFIG = {\n  flipHorizontal: !1\n},\n    MULTI_PERSON_INFERENCE_CONFIG = {\n  flipHorizontal: !1,\n  maxDetections: 5,\n  scoreThreshold: .5,\n  nmsRadius: 20\n};\n\nfunction validateMultiPersonInputConfig(e) {\n  var t = e.maxDetections,\n      r = e.scoreThreshold,\n      n = e.nmsRadius;\n  if (t <= 0) throw new Error(\"Invalid maxDetections \" + t + \". Should be > 0\");\n  if (r < 0 || r > 1) throw new Error(\"Invalid scoreThreshold \" + r + \". Should be in range [0.0, 1.0]\");\n  if (n <= 0) throw new Error(\"Invalid nmsRadius \" + n + \".\");\n}\n\nvar PoseNet = function () {\n  function e(e, t) {\n    this.baseModel = e, this.inputResolution = t;\n  }\n\n  return e.prototype.estimateMultiplePoses = function (e, t) {\n    return void 0 === t && (t = MULTI_PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {\n      var r, n, o, i, s, a, u, l, f, c, d, p, h, m, g, _, I, E, v, N, y;\n\n      return __generator(this, function (T) {\n        switch (T.label) {\n          case 0:\n            return r = __assign({}, MULTI_PERSON_INFERENCE_CONFIG, t), validateMultiPersonInputConfig(t), n = this.baseModel.outputStride, o = this.inputResolution, assertValidOutputStride(n), assertValidResolution(this.inputResolution, n), i = getInputTensorDimensions(e), s = i[0], a = i[1], u = padAndResizeTo(e, [o, o]), l = u.resized, f = u.padding, c = this.baseModel.predict(l), d = c.heatmapScores, p = c.offsets, h = c.displacementFwd, m = c.displacementBwd, [4, toTensorBuffers3D([d, p, h, m])];\n\n          case 1:\n            return g = T.sent(), _ = g[0], I = g[1], E = g[2], v = g[3], [4, decodeMultiplePoses(_, I, E, v, n, r.maxDetections, r.scoreThreshold, r.nmsRadius)];\n\n          case 2:\n            return N = T.sent(), y = scaleAndFlipPoses(N, [s, a], [o, o], f, r.flipHorizontal), d.dispose(), p.dispose(), h.dispose(), m.dispose(), l.dispose(), [2, y];\n        }\n      });\n    });\n  }, e.prototype.estimateSinglePose = function (e, t) {\n    return void 0 === t && (t = SINGLE_PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {\n      var r, n, o, i, s, a, u, l, f, c, d, p, h, m, g, _;\n\n      return __generator(this, function (I) {\n        switch (I.label) {\n          case 0:\n            return r = __assign({}, SINGLE_PERSON_INFERENCE_CONFIG, t), n = this.baseModel.outputStride, o = this.inputResolution, assertValidOutputStride(n), assertValidResolution(o, n), i = getInputTensorDimensions(e), s = i[0], a = i[1], u = padAndResizeTo(e, [o, o]), l = u.resized, f = u.padding, c = this.baseModel.predict(l), d = c.heatmapScores, p = c.offsets, h = c.displacementFwd, m = c.displacementBwd, [4, decodeSinglePose(d, p, n)];\n\n          case 1:\n            return g = I.sent(), _ = scaleAndFlipPoses([g], [s, a], [o, o], f, r.flipHorizontal), d.dispose(), p.dispose(), h.dispose(), m.dispose(), l.dispose(), [2, _[0]];\n        }\n      });\n    });\n  }, e.prototype.estimatePoses = function (e, t) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (r) {\n        switch (r.label) {\n          case 0:\n            return \"single-person\" != t.decodingMethod ? [3, 2] : [4, this.estimateSinglePose(e, t)];\n\n          case 1:\n            return [2, [r.sent()]];\n\n          case 2:\n            return [2, this.estimateMultiplePoses(e, t)];\n        }\n      });\n    });\n  }, e.prototype.dispose = function () {\n    this.baseModel.dispose();\n  }, e;\n}();\n\nfunction loadMobileNet(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    var t, r, n, o, i, s;\n    return __generator(this, function (a) {\n      switch (a.label) {\n        case 0:\n          if (t = e.outputStride, r = e.quantBytes, n = e.multiplier, null == tf) throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\\n        model.\");\n          return o = mobileNetCheckpoint(t, n, r), [4, loadGraphModel(e.modelUrl || o)];\n\n        case 1:\n          return i = a.sent(), s = new MobileNet(i, t), [2, new PoseNet(s, e.inputResolution)];\n      }\n    });\n  });\n}\n\nfunction loadResNet(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    var t, r, n, o, i;\n    return __generator(this, function (s) {\n      switch (s.label) {\n        case 0:\n          if (t = e.outputStride, r = e.quantBytes, null == tf) throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\\n        model.\");\n          return n = resNet50Checkpoint(t, r), [4, loadGraphModel(e.modelUrl || n)];\n\n        case 1:\n          return o = s.sent(), i = new ResNet(o, t), [2, new PoseNet(i, e.inputResolution)];\n      }\n    });\n  });\n}\n\nfunction load(e) {\n  return void 0 === e && (e = MOBILENET_V1_CONFIG), __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (t) {\n      return \"ResNet50\" === (e = validateModelConfig(e)).architecture ? [2, loadResNet(e)] : \"MobileNetV1\" === e.architecture ? [2, loadMobileNet(e)] : [2, null];\n    });\n  });\n}\n\nexport { decodeMultiplePoses, decodeSinglePose, MobileNet, partChannels, partIds, partNames, poseChain, load, PoseNet, VALID_INPUT_RESOLUTION, getAdjacentKeyPoints, getBoundingBox, getBoundingBoxPoints, scalePose };","map":null,"metadata":{},"sourceType":"module"}