"use strict";
/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EPSILON_FLOAT32 = 1e-7;
exports.EPSILON_FLOAT16 = 1e-4;
/** Convenient class for storing tensor-related data. */
var DataStorage = /** @class */ (function () {
    function DataStorage(backend, dataMover) {
        this.backend = backend;
        this.dataMover = dataMover;
        this.data = new WeakMap();
        this.dataIdsCount = 0;
    }
    DataStorage.prototype.get = function (dataId) {
        if (!this.data.has(dataId)) {
            this.dataMover.moveData(this.backend, dataId);
        }
        return this.data.get(dataId);
    };
    DataStorage.prototype.set = function (dataId, value) {
        this.dataIdsCount++;
        this.data.set(dataId, value);
    };
    DataStorage.prototype.has = function (dataId) {
        return this.data.has(dataId);
    };
    DataStorage.prototype.delete = function (dataId) {
        this.dataIdsCount--;
        return this.data.delete(dataId);
    };
    DataStorage.prototype.numDataIds = function () {
        return this.dataIdsCount;
    };
    return DataStorage;
}());
exports.DataStorage = DataStorage;
/**
 * The interface that defines the kernels that should be implemented when
 * adding a new backend. New backends don't need to implement every one of the
 * methods, this can be done gradually (throw an error for unimplemented
 * methods).
 */
var KernelBackend = /** @class */ (function () {
    function KernelBackend() {
    }
    KernelBackend.prototype.time = function (f) {
        return notYetImplemented();
    };
    KernelBackend.prototype.read = function (dataId) {
        return notYetImplemented();
    };
    KernelBackend.prototype.readSync = function (dataId) {
        return notYetImplemented();
    };
    KernelBackend.prototype.numDataIds = function () {
        return notYetImplemented();
    };
    KernelBackend.prototype.disposeData = function (dataId) {
        return notYetImplemented();
    };
    KernelBackend.prototype.fromPixels = function (pixels, numChannels) {
        return notYetImplemented();
    };
    KernelBackend.prototype.write = function (values, shape, dtype) {
        return notYetImplemented();
    };
    KernelBackend.prototype.move = function (dataId, values, shape, dtype) {
        return notYetImplemented();
    };
    KernelBackend.prototype.memory = function () {
        return notYetImplemented();
    };
    /** Returns the highest precision for floats in bits (e.g. 16 or 32) */
    KernelBackend.prototype.floatPrecision = function () {
        return notYetImplemented();
    };
    /** Returns the smallest representable number.  */
    KernelBackend.prototype.epsilon = function () {
        return this.floatPrecision() === 32 ? exports.EPSILON_FLOAT32 : exports.EPSILON_FLOAT16;
    };
    KernelBackend.prototype.batchMatMul = function (a, b, transposeA, transposeB) {
        return notYetImplemented();
    };
    KernelBackend.prototype.fusedBatchMatMul = function (_a) {
        var a = _a.a, b = _a.b, transposeA = _a.transposeA, transposeB = _a.transposeB, bias = _a.bias, activation = _a.activation, preluActivationWeights = _a.preluActivationWeights;
        return notYetImplemented();
    };
    KernelBackend.prototype.slice = function (x, begin, size) {
        return notYetImplemented();
    };
    KernelBackend.prototype.stridedSlice = function (x, begin, end, strides) {
        return notYetImplemented();
    };
    KernelBackend.prototype.unstack = function (x, axis) {
        return notYetImplemented();
    };
    KernelBackend.prototype.reverse = function (a, axis) {
        return notYetImplemented();
    };
    KernelBackend.prototype.concat = function (tensors, axis) {
        return notYetImplemented();
    };
    KernelBackend.prototype.neg = function (a) {
        return notYetImplemented();
    };
    KernelBackend.prototype.add = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.addN = function (tensors) {
        return notYetImplemented();
    };
    KernelBackend.prototype.subtract = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.multiply = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.realDivide = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.floorDiv = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.sum = function (x, axes) {
        return notYetImplemented();
    };
    KernelBackend.prototype.prod = function (x, axes) {
        return notYetImplemented();
    };
    KernelBackend.prototype.unsortedSegmentSum = function (x, segmentIds, numSegments) {
        return notYetImplemented();
    };
    KernelBackend.prototype.argMin = function (x, axis) {
        return notYetImplemented();
    };
    KernelBackend.prototype.argMax = function (x, axis) {
        return notYetImplemented();
    };
    KernelBackend.prototype.equal = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.notEqual = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.less = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.lessEqual = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.greater = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.greaterEqual = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.logicalNot = function (a) {
        return notYetImplemented();
    };
    KernelBackend.prototype.logicalAnd = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.logicalOr = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.where = function (condition) {
        return notYetImplemented();
    };
    KernelBackend.prototype.select = function (condition, a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.topk = function (x, k, sorted) {
        return notYetImplemented();
    };
    KernelBackend.prototype.min = function (x, axes) {
        return notYetImplemented();
    };
    KernelBackend.prototype.minimum = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.mod = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.max = function (x, axes) {
        return notYetImplemented();
    };
    KernelBackend.prototype.maximum = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.all = function (x, axes) {
        return notYetImplemented();
    };
    KernelBackend.prototype.any = function (x, axes) {
        return notYetImplemented();
    };
    KernelBackend.prototype.squaredDifference = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.ceil = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.floor = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.round = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.sign = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.isNaN = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.isInf = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.isFinite = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.pow = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.exp = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.expm1 = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.log = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.log1p = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.sqrt = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.rsqrt = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.square = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.reciprocal = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.relu = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.relu6 = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.prelu = function (x, a) {
        return notYetImplemented();
    };
    KernelBackend.prototype.elu = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.eluDer = function (dy, y) {
        return notYetImplemented();
    };
    KernelBackend.prototype.selu = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.int = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.clip = function (x, min, max) {
        return notYetImplemented();
    };
    KernelBackend.prototype.abs = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.complexAbs = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.sigmoid = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.softplus = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.sin = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.cos = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.tan = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.asin = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.acos = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.atan = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.atan2 = function (a, b) {
        return notYetImplemented();
    };
    KernelBackend.prototype.sinh = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.cosh = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.tanh = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.asinh = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.acosh = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.atanh = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.erf = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.step = function (x, alpha) {
        return notYetImplemented();
    };
    KernelBackend.prototype.fusedConv2d = function (_a) {
        var input = _a.input, filter = _a.filter, convInfo = _a.convInfo, bias = _a.bias, activation = _a.activation, preluActivationWeights = _a.preluActivationWeights;
        return notYetImplemented();
    };
    KernelBackend.prototype.conv2d = function (x, filter, convInfo) {
        return notYetImplemented();
    };
    KernelBackend.prototype.conv2dDerInput = function (dy, filter, convInfo) {
        return notYetImplemented();
    };
    KernelBackend.prototype.conv2dDerFilter = function (x, dY, convInfo) {
        return notYetImplemented();
    };
    KernelBackend.prototype.fusedDepthwiseConv2D = function (_a) {
        var input = _a.input, filter = _a.filter, convInfo = _a.convInfo, bias = _a.bias, activation = _a.activation, preluActivationWeights = _a.preluActivationWeights;
        return notYetImplemented();
    };
    KernelBackend.prototype.depthwiseConv2D = function (input, filter, convInfo) {
        return notYetImplemented();
    };
    KernelBackend.prototype.depthwiseConv2DDerInput = function (dy, filter, convInfo) {
        return notYetImplemented();
    };
    KernelBackend.prototype.depthwiseConv2DDerFilter = function (x, dY, convInfo) {
        return notYetImplemented();
    };
    KernelBackend.prototype.conv3d = function (x, filter, convInfo) {
        return notYetImplemented();
    };
    KernelBackend.prototype.conv3dDerInput = function (dy, filter, convInfo) {
        return notYetImplemented();
    };
    KernelBackend.prototype.conv3dDerFilter = function (x, dY, convInfo) {
        return notYetImplemented();
    };
    KernelBackend.prototype.maxPool = function (x, convInfo) {
        return notYetImplemented();
    };
    KernelBackend.prototype.maxPoolBackprop = function (dy, x, y, convInfo) {
        return notYetImplemented();
    };
    KernelBackend.prototype.avgPool = function (x, convInfo) {
        return notYetImplemented();
    };
    KernelBackend.prototype.avgPoolBackprop = function (dy, x, convInfo) {
        return notYetImplemented();
    };
    KernelBackend.prototype.avgPool3d = function (x, convInfo) {
        return notYetImplemented();
    };
    KernelBackend.prototype.avgPool3dBackprop = function (dy, x, convInfo) {
        return notYetImplemented();
    };
    KernelBackend.prototype.maxPool3d = function (x, convInfo) {
        return notYetImplemented();
    };
    KernelBackend.prototype.maxPool3dBackprop = function (dy, x, y, convInfo) {
        return notYetImplemented();
    };
    KernelBackend.prototype.reshape = function (x, shape) {
        return notYetImplemented();
    };
    KernelBackend.prototype.cast = function (x, dtype) {
        return notYetImplemented();
    };
    KernelBackend.prototype.tile = function (x, reps) {
        return notYetImplemented();
    };
    KernelBackend.prototype.pad = function (x, paddings, constantValue) {
        return notYetImplemented();
    };
    KernelBackend.prototype.transpose = function (x, perm) {
        return notYetImplemented();
    };
    KernelBackend.prototype.gather = function (x, indices, axis) {
        return notYetImplemented();
    };
    KernelBackend.prototype.gatherND = function (x, indices) {
        return notYetImplemented();
    };
    KernelBackend.prototype.scatterND = function (indices, updates, shape) {
        return notYetImplemented();
    };
    KernelBackend.prototype.batchToSpaceND = function (x, blockShape, crops) {
        return notYetImplemented();
    };
    KernelBackend.prototype.spaceToBatchND = function (x, blockShape, paddings) {
        return notYetImplemented();
    };
    KernelBackend.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {
        return notYetImplemented();
    };
    KernelBackend.prototype.resizeBilinearBackprop = function (dy, x, alignCorners) {
        return notYetImplemented();
    };
    KernelBackend.prototype.resizeNearestNeighbor = function (x, newHEight, newWidth, alignCorners) {
        return notYetImplemented();
    };
    KernelBackend.prototype.resizeNearestNeighborBackprop = function (dy, x, alignCorners) {
        return notYetImplemented();
    };
    KernelBackend.prototype.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {
        return notYetImplemented();
    };
    KernelBackend.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta) {
        return notYetImplemented();
    };
    KernelBackend.prototype.LRNGrad = function (dy, inputImage, outputImage, radius, bias, alpha, beta) {
        return notYetImplemented();
    };
    KernelBackend.prototype.multinomial = function (logits, normalized, numSamples, seed) {
        return notYetImplemented();
    };
    KernelBackend.prototype.oneHot = function (indices, depth, onValue, offValue) {
        return notYetImplemented();
    };
    KernelBackend.prototype.cumsum = function (x, axis, exclusive, reverse) {
        return notYetImplemented();
    };
    KernelBackend.prototype.nonMaxSuppression = function (boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
        return notYetImplemented();
    };
    KernelBackend.prototype.fft = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.ifft = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.complex = function (real, imag) {
        return notYetImplemented();
    };
    KernelBackend.prototype.real = function (input) {
        return notYetImplemented();
    };
    KernelBackend.prototype.imag = function (input) {
        return notYetImplemented();
    };
    KernelBackend.prototype.cropAndResize = function (image, boxes, boxIndex, cropSize, method, extrapolationValue) {
        return notYetImplemented();
    };
    KernelBackend.prototype.depthToSpace = function (x, blockSize, dataFormat) {
        return notYetImplemented();
    };
    // Aligns with the "SplitV" kernel in TensorFlow.
    KernelBackend.prototype.split = function (value, sizeSplits, axis) {
        return notYetImplemented();
    };
    KernelBackend.prototype.sparseToDense = function (sparseIndices, sparseValues, outputShape, defaultValue) {
        return notYetImplemented();
    };
    KernelBackend.prototype.diag = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.fill = function (shape, value, dtype) {
        throw new Error('Not yet implemented.');
    };
    KernelBackend.prototype.onesLike = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.zerosLike = function (x) {
        return notYetImplemented();
    };
    KernelBackend.prototype.linspace = function (start, stop, num) {
        return notYetImplemented();
    };
    KernelBackend.prototype.dispose = function () {
        return notYetImplemented();
    };
    return KernelBackend;
}());
exports.KernelBackend = KernelBackend;
function notYetImplemented() {
    throw new Error('Not yet implemented or not found in the registry. ' +
        'Did you forget to import the kernel?');
}
//# sourceMappingURL=backend.js.map